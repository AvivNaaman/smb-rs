use std::{default, error::Error, io::{Cursor, Read, SeekFrom, Write}, net::TcpStream, vec};

use binrw::{
    binwrite, helpers::{read_u24, until_eof, write_u24}, BinRead, BinResult, BinWrite, NullString, NullWideString, PosValue
};

use binrw::io::TakeSeekExt;

mod pos_marker;
use pos_marker::PosMarker;
use rand::Rng;
use smb::packets::{netbios::{NetBiosTcpMessage, NetBiosTcpMessageContent}, smb1::SMB1NegotiateMessage};


fn main() -> Result<(), Box<dyn Error>> {
    let raw_packet: &[u8] = &[
        0x00, 0x00, 0x01, 0x14, 0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0xf7, 0x60, 0xd9, 0x52, 0xa6, 0xb7, 0xef, 0x11, 0x8b, 0x78, 0x00, 0x0c, 0x29, 0x80, 0x16, 0x82, 0x70, 0x00, 0x00, 0x00, 
        0x06, 0x00, 
        0x00, 0x00, 0x02, 0x02, 0x10, 0x02, 0x00, 0x03, 0x02, 0x03, 0x11, 0x03, 0x00, 0x00, 

        0x01, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x01, 0x00, 0xd2, 0x23, 0xe6, 0xe1, 0x0b, 0xe1, 0x77, 0x81, 0x04, 0xb3, 0xa8, 0xcf, 0x3b, 0xaa, 0x57, 0x90, 0x22, 0x28, 0x4e, 0x23, 0x59, 0x7f, 0xd7, 0xb3, 0x4c, 0xf4, 0x8f, 0xbc, 0xa5, 0x26, 0x76, 0x97, 0x00, 0x00, 
        0x02, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x03, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x03, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00,
        0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x32, 0x00, 0x37, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00
    ];

    // Well, it appears that you must always do the multi-protocol negotiation dance with Windows.
    let raw_smb1_packet: &[u8] = &[
        0x00, 0x00, 0x00, 0x45, 0xff, 0x53, 0x4d, 0x42, 0x72, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x22, 0x00, 0x02, 0x4e, 0x54, 0x20, 0x4c, 0x4d, 0x20, 0x30, 0x2e, 0x31, 0x32, 0x00, 0x02, 0x53, 0x4d, 0x42, 0x20, 0x32, 0x2e, 0x30, 0x30, 0x32, 0x00, 0x02, 0x53, 0x4d, 0x42, 0x20, 0x32, 0x2e, 0x3f, 0x3f, 0x3f, 0x00, 
    ];

    // parse raw smb1 packet -- first netBiod header, then SMB1NegotiateMessage:
    let packet = NetBiosTcpMessage::read(&mut Cursor::new(raw_smb1_packet))?;
    let smb1 = match &packet.message {
        NetBiosTcpMessageContent::SMB1Message(msg) => {msg},
        NetBiosTcpMessageContent::SMB2Message(_) => {panic!("Expected SMB1 message, got SMB2 message.")}
    };
    println!("{:?}", smb1);
    assert!(smb1.is_smb2_supported());

    // let packet = NetBiosTcpMessage::read(&mut Cursor::new(raw_packet));
    // let mut message_cursor = Cursor::new(packet?.message);
    // _ = dbg!(SMB2Message::read(&mut message_cursor));

    // let mut writer = Cursor::new(Vec::new());
    // SMB2Message::build().write(&mut writer)?;
    
    // let output_vec = writer.into_inner();

    // // Now try to parse the output:
    // let mut reader = Cursor::new(&output_vec);
    // let parsed = SMB2Message::read(&mut reader)?;
    // println!("{:?}", parsed);

    let mut tcp_connection = TcpStream::connect("172.16.204.128:445")?;

    // first send the raw smb1 packet:
    tcp_connection.write_all(raw_smb1_packet)?;
    let mut ns = binrw::io::NoSeek::new(&mut tcp_connection);
    let nb_msg = NetBiosTcpMessage::read(&mut ns)?;
    dbg!(&nb_msg);
    // and expect smb2 response:
    // let mut smb2_first_response: Vec<u8> = vec![];
    // tcp_connection.read_to_end(&mut smb2_first_response)?;
    // let smb2_first_response = NetBiosTcpMessage::read(&mut Cursor::new(smb2_first_response))?;
    // dbg!(&smb2_first_response);

    // // trim last 2 bytes of the output_vec and copy to a new vec:
    // let output_vec = output_vec[..output_vec.len()-2].to_vec();
    // // Write netbios header first:
    // let netbios_message = NetBiosTcpMessage {
    //     stream_protocol_length: output_vec.len() as u32,
    //     message: output_vec
    // };

    // let mut netbios_message_bytes = Cursor::new(Vec::new());
    // netbios_message.write(&mut netbios_message_bytes)?;

    // tcp_connection.write_all(&netbios_message_bytes.into_inner())?;
    // let mut response : Vec<u8>= vec![];
    // tcp_connection.read_to_end(&mut response)?;

    Ok(())
}
